# 类

ts 全名支持 ES2015 中引入的 class 关键字。

和其他的 js 语言特性一样，ts 添加了类型标注和其他语法，让你能表达类和其他类型的关系。

## 类成员

这里是一个最基本的类 —— 一个空的类

```typescript
class Point {

}
```

这个类暂时没用，所以让我们开始添加一个成员.

### 字段

一个字段声明在一个类上创建一个公共的可写的属性:

```typescript
class Point {
  x: number;
  y: number;
}
const pt = new Point();
pt.x = 0;
pt.y = 0;
```

和其他地方一样，类型标注是可选的，但是如果没有指定时会被隐式推断为 any。

字段也可以被初始化，这些将在类实例化时自动运行:

```typescript
class Point {
  x = 0;
  y = 0;
}
const pt = new Point();
console.log(pt.x, pt.y)
```

和 `const`,`let`,`var` 一样，类属性的初始化会用于它的类型推断：

```typescript
const pt = new Point();
pt.x = '0' ; // error: Type 'string' is not assignable to type 'number'.
```

#### strictPropertyInitialization

strictPropertyInitialization 设置绝顶一个类字段在构造函数中是否需要被初始化.

```typescript
class BadGreeter {
  name: string; // error: Property 'name' has no initializer and is not definitely assigned in the constructor.
}
```

```typescript
class GoodGreeter {
  name: string;
  constructor() {
    this.name = 'hello';
  }
}
```

注意，在构造函数里字段需要被初始化。ts 并不会分析你在构造函数中调用的方法来检测初始化过程，因为一个派生类可能重写了这些方法，并且初始化成员失败。

如果你打算通过构造函数意外的方式类初始化一个字段（比如一个外部库为你创建了类的一部分），你可以使用 *明确的赋值断言操作符*， `!`:

```typescript
class OKGreeter {
  name!: string; // 不初始化也是 ok 的
}
```

### readonly

字段可能会有 `readonly` 修饰符作为前缀，这点防止了在构造函数之外对字段的再次赋值。

```typescript
class Greeter {
  readonly name: string = 'world';
  constructor(otherName?: string) {
    if (!otherName !== undefined) {
      this.name = otherName;
    }
  }
  err() {
    this.name = 'not ok'; // error: Cannot assign to 'name' because it is a read-only property.
  }
}
const g = new Greeter();
g.name = 'also not ok'; // error: Cannot assign to 'name' because it is a read-only property.
```

### 构造函数

构造函数和函数非常类似的，你可以为参数添加类型标注、默认值和重载:

```typescript
class Point {
  x: number;
  y: number;
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
}
```

```typescript
class Point {
  constructor(x: number, y: string);
  constructor(s: string);
  constructor(xs: any, y?: any) {
    // ...
  }
}
```

构造函数签名和函数签名有一点点不同:

- 构造器不能有类型参数 —— 类型参数属于外部的类声明，我们会在随后学习
- 构造器不能有返回值类型标注 —— 返回值类型始终是类实例的类型

#### super 调用

和 js 中一样，如果你有一个基类，在你的构造函数体访问 this 之前, 你需要调用 `super()`，


```typescript
class base {
  k = 4;
}
class Derived extends Base {
  constructor() {
    console.log(this.k); // error:'super' must be called before accessing 'this' in the constructor of a derived class.
    super();
  }
}
```

在 js 中，忘记调用 super 是一个很容易犯的错误，但是 ts 会在必要时告诉你。

### 方法

一个类上的函数属性被成为 *方法*。方法可以使用所有与函数和构造函数相同的类型标注：

```typescript
class Point {
  x = 10;
  y = 10;
  scale(n: number):void {
    this.x *= n;
    this.y *= n;
  }
}
```

在标准的类型标注之外，ts 并没有为方法添加额外的东西。

注意到在方法体内部，仍然必须通过 `this.` 来访问字段和其他方法。一个方法体中非法的变量名总是指向当前作用域。

```typescript
let x: number = 0;
class C {
  x: string = 'hello';
  m() {
    x = 'world'; // x 指向外部的 x， error: // Type 'string' is not assignable to type 'number'.
  }
}
```

### Getters/Setters

类也可以有访问器:

```typescript
class C {
  _length = 0;
  get length() {
    return this._length;
  }
  set length(value) {
    this._length = value;
  }
}
```

> 注意在 js 中一个没有额外逻辑的 get/set 没什么用，如果你不需要在 get/set 操作中添加额外的逻辑，那么设置为公开字段会更好

ts 对于访问器有一些特殊的类型推断规则:

- 如果只有 get 而没有 set，属性默认为 readonly
- 如果 setter 参数的类型没有指定，它会被推断为 getter 的返回值类型
- getter 和 setter 必须有相同的 成员可见性

从  ts 4.3 开始，getting 和 setting 具有不同的类型是可能的:

```typescript
class Thing {
  _size = 0;
  get size(): number {
    return this._size;
  }
  set size(value: string | number | boolean) {
    let num = Number(value);
    if (!Number.isFinite(num)) {
      this._size = 0;
      return;
    }
    this._size = num;
  }
}
```

### 索引签名

类可以声明索引签名，这点和对象类型的索引签名是一样的:

```typescript
class MyClass {
  [s: string]: boolean | ((s: string) => boolean);
  check(s: string) {
    return this[s] as boolean;
  }
}
```

由于索引签名类型也需要捕获方法类型，所以使用这些类型不太容易。通常来说将索引数据存放在另一个地方而不是类实例上是个更好的办法。

## 类继承

和其他语言面向对象的特性一样，js 的类可以从其他基类中继承.

### `implements` 语句

你可以使用一个 implements 检查一个类是否满足一个指定的接口。如果类没有实现接口，就会产生一个错误:

```typescript
interface Pingable {
  ping(): void;
}
class Sonar implements Pingable {
  ping() {
    console.log('ping')
  }
}
class Ball implements Pingable {
  // error: Class 'Ball' incorrectly implements interface 'Pingable'.Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
  pong() {
    console.log('pong')
  }
}
```

类同样可以实现多个接口，比如 `class C implements A,B {}`

#### 注意事项

理解一个 implements 语句仅仅是一个判断类能否被当做接口类型的检查是很重要的，它完全不会修改类或其方法的类型。一个常见的错误源于假设一个 implements 语句会修改类的类型 —— 它并不会。

``` typescript
interface Checkable {
  check(name: string): boolean;
}
class NameChecker implements Checkable {
  check(s) {
    // error: Parameter 's' implicitly has an 'any' type.
    return s.toLowercase() === 'ok';
  }
}
```

这个例子中，我们可能期望 `s` 的类型会被 `check` 的 `name: string` 参数所影响，但其实不会 —— `implements` 语句并不会改变类主题的检查方式或其的类型推断

相似的是，实现一个可选属性的接口并不会创建那个属性:

```typescript
interface A {
  x: number;
  y?: number;
}
class C implements A {
  x = 0;
}
const c = new C();
c.y = 10; // error: Property 'y' does not exist on type 'C'.
```

### `extends` 语句

类可以从其他基类中 `继承`，一个派生类具有基类的所有属性和方法，并可以定义额外的成员。

```typescript
class Animal {
  move() {
    console.log('moving');
  }
}
class Dog extends Animal {
  woof(times: number) {
    for (let i = 0; i < times; i++) {
      console.log('woof');
    }
  }
}
const d = new Dog();
d.move(); // 基类方法
d.woof(3); // 派生类方法
```

#### 方法重写

一个派生类同样可以重写基类的字段或属性，你可以通过 `super.` 的语法来访问基类的方法。请注意，由于 js 的类是一个简单的查找对象，所以没有 “super 字段” 的定义。

ts 强制派生类始终是其基类的子类型。

举个例子，下面是重写方法的方式:

```typescript
class Base {
  greet() {
    console.log('hello world')
  }
}
class Derived extends Base {
  greet(name?: string) {
    if (name === undefined) {
      super.greet();
    } else {
      console.log(name.toUpperCase());
    }
  }
}
const d = new Derived();
d.greet(); // hello world;
d.greet('reader') ; //  READER;
```

派生类遵循基类是很重要的，记住通过一个基类引用来引用派生类实例是很常见的(这始终是合法的):

```typescript
const b: Base = d;
b.greet();
```

如果派生类并没有遵循基类的呢?

```typescript
class Base {
  greet() {
    console.log('hello world');
  }
}
class Derived extends Base {
  // 这里的 name 现在是必传参数了
  // error:Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.Type '(name: string) => void' is not assignable to type '() => void'.
  greet(name: string) {
    console.log(name.toUpperCase());
  }
}
```

如果我们忽略 error 继续编辑代码，这个实例就会 crash: 

```typescript
const b: Base = new Derived();
b.greet(); // // Crashes because "name" will be undefined
```

#### 纯类型字段声明

当开启 `target >= ES2022` 或 `useDefineForClassFields` 设为 true 时，类字段在父类构造函数完成后初始化，会重写父类设置的任意值。当你只想为一个继承字段设置一个更加精确的类型时，这会是个问题。要处理这些情况，你可以编写 declare 向 ts 表示这个字段声明不应该有运行时影响.

```typescript
interface Animal {
  dateOfBirth: any;
}
interface Dog extends Animal {
  breed: any;
}
class AnimalHouse {
  resident: Animal;
  constructor(animal: Animal) {
    this.resident = animal;
  }
}
class DogHouse extends AnimalHouse {
  declare resident: Dog;
  constructor(dog: Dog) {
    super(dog);
  }
}
```

#### 初始化顺序

在某些情况狂下 js 类的初始化顺序可能会让你感到惊讶。让我们考虑下面的代码:

```typescript
class Base {
  name = 'base';
  constructor() {
    console.log(this.name);
  }
}
class Derived extends Base {
  name = 'derived'
}
const d = new Derived(); // 打印 base，而不是 derived
```

这发生了啥?

类初始化的顺序在 js 中是这样定义的:

- 基类字段初始化
- 基类构造函数运行
- 派生类字段初始化
- 派生类构造函数运行

这意味着基类构造函数在执行期间看到的是自己的 name，因为派生类的字段初始化还没有运行。

#### 继承内置类型

> 注意: 如果你不打算从 Array、Error、Map 等内置类型中继承，或者你的编译对象被明确设置为 ES6/ES2015 或更高，你可以跳过这个章节

TODO: TRANSLATE

## 成员可见性

你可以使用 ts 来控制某些方法或属性是否对类之外的代码可见。

### `public`

类成员默认的可见性是 `public`。一个 `public` 的成员可以在任何地方可访问。

```typescript
class Greeter {
  public greet() {
    console.log('hi')
  }
}
const g = new Greeter();
g.greet();
```

由于 `public` 已经是默认的可见性修饰符了，所以你永远都不用在类成员上写它，但是出于 代码风格/可读性的原因，你可能会这样做。

### `protected`

`protected` 成员只对声明它们的类的子类可见

```typescript
class Greeter {
  public greet() {
    console.log(this.getName());
  }
  protected getName() {
    return 'name'
  }
}
class SpecialGreeter extends Greeter {
  public howdy() {
    console.log(this.getName()); // ok
  }
}
const g = new SpecialGreeter();
g.greet(); // ok
g.getName(); // error: Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses
```

#### 暴露 `protected` 成员

派生类需要遵循基类行为，但是可以选择暴露一个具有更多功能的子类型。这包括让 `protected` 成员变成 `public`:

```typescript
class Base {
  protected m = 10;
}
class Derived extends Base {
  m = 15; // 不用加修饰符，因为默认就是 public
}
const d = new Derived();
console.log(d.m); // OK
```

注意到 Derived 已经可以随意读写 `m` 了，所以这不是有意修改这种情况的 “安全性”。这里要注意的主要在于，在派生类中，如果这种暴露不是有意的，那么我们需要小心的重复 protected 修饰符。

#### 跨级访问 `protected`

不同的面向对象语言对于能否通过基类引用来访问 protected 成员的处理是不同的:

```typescript
class Base {
  protected x: number = 1;
}
class Derived1 extends Base {
  protected x: number = 5;
}
class Derived2 extends Base {
  f1(other: Derived2) {
    other.x = 10;
  }
  f2(other: Base) {
    other.x = 10; // Property 'x' is protected and only accessible through an instance of class 'Derived2'. This is an instance of class 'Base'.
  }
}
```

举个例子，java 认为这是合法的；另一方面， C# 和 C++ 认为这种代码是不合法的。

TS 和 C#、C++ 是一边的，因为访问 Derived2 的 x 应该只在 Derived2 的子类中是合法的，而 Derived1 显然不是其中之一。此外，如果通过 Derived1 的引用访问 x 是非法的，那么通过基类引用的访问 x 也不会改善这种情况。

另外参阅 [为什么我不能从派生类中访问 Protected 成员](https://learn.microsoft.com/zh-cn/archive/blogs/ericlippert/why-cant-i-access-a-protected-member-from-a-derived-class)，其解释了更多 C# 的原因。

### private

`private` 类似于 `protected` ，但不允许从子类中访问该成员。

```typescript
class Base {
  private x = 0;
}
const b = new Base();
console.log(b.x); // error: 不能从类外部访问
```

由于 `private` 成员对于派生类是不可见的，所以派生类不能修改它们的可见性:

```typescript
class Base {
  private x = 0;
}

class Derived extends Base {
  x = 1; // error: Class 'Derived' incorrectly extends base class 'Base'.Property 'x' is private in type 'Base' but not in type 'Derived'.
}
```

#### 跨实例访问 `private`

不同的 OOP 语言对于同一个类的不同实例是否可以访问彼此的私有成员存在分歧，虽然 JAVA、C#、C++、Swift 和  PHP 等语言允许这样做，Ruby 不允许。

ts 允许跨实例访问 `private` 成员:

```typescript
class A {
  private x = 10;
  public sameAs(other: A) {
    return other.x === this.x; // ok
  }
}
```

#### 注意事项

和 ts 类型系统的其他点一样，`private` 和 `protected` 只在类型检查期间强制执行。

这意味着像 in 或简单的属性查找这样的 js 运行时结构仍然能够访问 `private` 和 `protected` 成员:

```typescript
class MySafe {
  private secretKey = 12345;
}
```

```javascript
const s = new MySafe();
console.log(s.secretKey); // 12345
```

`private` 还允许在类型检查时使用括号进行访问。这使得通过 privated 声明的字段更容易被类似单元测试的东西访问到，缺点是这些字段是 *软性私有的*，并不是严格执行 priva te

```typescript
class MySafe {
  private secretKey = 12345;
}

const s = new MySafe();

console.log(s.secretKey); // error: Property 'secretKey' is private and only accessible within class 'MySafe'.

console.log(s['secretKey']); // ok
```

和 ts 的 private 不一样，js 的私有字段(#)在编译后保留了 private，之前的括号访问的方式也是不可用的，这让它成为 *硬性私有的*

```typescript
class Dog {
  #barkAmount = 0;
  personality = 'happy';
  constructor() {}
}
```

```javascript
"use strict";
class Dog {
  #barkAmount = 0;
  personality = "happy";
  constructor() { }
}
```

当编译为 ES2021 或更低时，ts 将使用 WeakMap 来替换 `#`;

```javascript
"use strict";
var _Dog_barkAmount;
class Dog {
    constructor() {
        _Dog_barkAmount.set(this, 0);
        this.personality = "happy";
    }
}
_Dog_barkAmount = new WeakMap();
```

如果你需要在类中保护值免于恶意修改，你应该使用提供运行时 privacy 的机制，比如闭包、Weakmap 或 private 字段。注意，这些在运行时添加的 privacy 检查可能会影响性能。
